#!/bin/bash

# set -e # set -o errexit # exit on errors, we dont need this, because we have set ERR trap.
set -u # set -o nounset # exit if trying to use an uninitialized variable
set -E # set -o errtrace # inherit ERR trap in subshells
set -T # set -o functrace # inherit DEBUG and RETURN traps on subshells
# set -C # set -o noclobber # error if a file redirection will override a file
# set -o pipefail # dont return last commands status in a pipe

#TODO: default arg parser as in python getargs
#TODO: default exit codes
#TODO: default behaviour in cron, redirect &1 &2


# write_msg - msg - print_msg
# write_log - log


:<<EOH
Documentation
#############
See also "Quickstart" at end of script.

    Copyright 2012, Bekir Dogan <bekir@bdgn.net>
    Distribution permitted under the GPL v2, as distributed by the
    Free Software Foundation.

Impatient?
----------
    #Example output: ":<<-'_is_spammer_outputs_'"
    #How to use: Enter script name without arguments.
    #            Or goto "Quickstart" at end of script.

Provides
--------
    #Given a domain name or IP(v4) address as input:
    #
    #Does an exhaustive set of queries to find the associated
    #network resources (short of recursing into TLDs).
    #
    #Checks the IP(v4) addresses found against Blacklist
    #nameservers.
    #
    #If found to be a blacklisted IP(v4) address,
    #reports the blacklist text records.
    #(Usually hyper-links to the specific report.)

Requires
--------
    * devfs mounted on /dev
    * procfs mounted on /proc
    * /var/lock directory, with write access
    * date, stat, dirname, mkdir (coreutils) -- tr, cut, mktemp, id, stty, readlink, cat, basename, cp
    * ps (procps)
    * logger (bsdutils)

Examples
--------

See Also
--------
    Some similar tools:
    http://www.bashinator.org/
    http://dberkholz.com/2011/04/07/bash-shell-scripting-libraries/
    https://github.com/codigorama/bash-toolbox
    http://code.google.com/p/shesfw/ # so simple, not complete

EOH

# == CONFIG VARIABLES ==
# These variables should be set prior to source this file

## <filename> or "syslog", full path or relative to script's own path,
## default is empty, if "default" it will be
## LOG_FILE=$BASEDIR/$BASENAME.log

LOG_FILE=default
LOG_LEVEL=DEBUG
OUTPUT_LEVEL=DEBUG
LOG_SYSLOG_FACILITY=user

## mail address to send mail on fatal errors, default empty (disabled)

MAIL_ON_ERROR=

# == INITIALIZE CONFIG PARAMETERS ==
BASENAME=${0##*/}
BASEDIR=$( cd $(dirname $0); pwd -P )

#TODO: Implementing log4sh should be good
LOG_FILE=${LOG_FILE:-default}
if [ "$LOG_FILE" = "default" ]; then
	LOG_FILE=$BASEDIR/$BASENAME.log
elif [ "${LOG_FILE:0:1}" != "/" ]; then
	LOG_FILE=$BASEDIR/$LOGFILE
fi

LOG_SYSLOG_FACILITY=${LOG_SYSLOG_FACILITY:-user}


# == helper functions ==
# from http://stackoverflow.com/questions/2264428/converting-string-to-lower-case-in-bash-shell-scripting

uppers=ABCDEFGHIJKLMNOPQRSTUVWXYZ
lowers=abcdefghijklmnopqrstuvwxyz
function lc { #usage: lc "SOME STRING" -> "some string"
	local i=0
	local OUTPUT=
	while ([ $i -lt ${#1} ]); do
		CUR=${1:$i:1}
		case $uppers in
		*$CUR*)
			CUR=${uppers%$CUR*}
			OUTPUT="${OUTPUT}${lowers:${#CUR}:1}"
			;;
		*)
			OUTPUT="${OUTPUT}$CUR"
			;;
		esac
		i=$((i+1))
	done
	echo "${OUTPUT}"
}

function uc { #usage: uc "some string" -> "SOME STRING"
	local i=0
	local OUTPUT=
	while ([ $i -lt ${#1} ]); do
		CUR=${1:$i:1}
		case $lowers in
		*$CUR*)
			CUR=${lowers%$CUR*}
			OUTPUT="${OUTPUT}${uppers:${#CUR}:1}"
			;;
    	*)
			OUTPUT="${OUTPUT}$CUR"
			;;
    	esac
    	i=$((i+1))
	done
	echo "${OUTPUT}"
}

function has_terminal {
	test -t 1
}

function is_interactive {
	test -n "${-//[^i]/}"
}

if is_interactive; then
	unset -f command_not_found_handle
	PS1='[skel:$SHLVL]'"$PS1"
fi

function is_running_via_termless_ssh {
	test -n "$SSH_CLIENT" -a -z "$SSH_TTY"
}

function is_running_via_cron {
	# from http://unix.stackexchange.com/questions/46789/check-if-script-is-started-by-cron-rather-than-invoked-manually
	local P_PID=$$  # start from current PID
	local CRON_IS_PARENT=0
	local CRONPID=$(ps ho %p -C cron)
	while [ $CRON_IS_PARENT -ne 1 ] && [ $P_PID -ne 1 ] ; do
		P_PID=$(ps ho %P -p $P_PID)
		[ $CRONPID -eq $P_PID ] && CRON_IS_PARENT=1
	done
	[ $CRONPID -eq 1 ]
}

function is_stdin_a_file {
	test "$(stat --print=%F --dereference /dev/fd/0 2>/dev/null)" = "regular file"
}

function is_stdout_a_file {
	test "$(stat --print=%F --dereference /dev/fd/1 2>/dev/null)" = "regular file"
}

function is_stdin_a_pipe {
	test "$(stat --print=%F --dereference /dev/fd/0 2>/dev/null)" = "fifo"
}

function is_stdout_a_pipe {
	test "$(stat --print=%F --dereference /dev/fd/1 2>/dev/null)" = "fifo"
}

function is_stdin_a_terminal {
	test -t 0
}

function is_stdout_a_terminal {
	test -t 1
}

# == LOCK MECHANISM ==
# Pure bash lock implementation



#TODO: remove all locks if previous process is vanished without
#      calling unlock_all

function lock {
    local LOCK_NAME=${1:-INTERNAL_GLOBAL}
    mkdir -p /var/lock/$BASENAME/ &>/dev/null
    mkdir /var/lock/$BASENAME/$LOCK_NAME &>/dev/null
}

function unlock {
    local LOCK_NAME=${1:-INTERNAL_GLOBAL}
    rmdir /var/lock/$BASENAME/$LOCK_NAME &>/dev/null
}

function locks {
    cd /var/lock/$BASENAME/
    for lock in *; do
        echo "$lock"
    done
	cd -
}

function unlock_all {
    rm -rf /var/lock/$BASENAME/
}

# user should define this functions
# onerror
# oninterrupt
# onquit

# cleanup leftovers if script fails
function internal_clean_up {
	unlock_all
}

# == SIGNAL FUNCTIONS ==

#TODO: default signal hanlers (trap)
#TODO: there should be debug (set -x, stepping: trap '(read -p "[$BASH_SOURCE:$LINENO] $BASH_COMMAND?")' DEBUG)
#TODO: print stack if failed

# Predefined handlers, userd shoud create their own onerror, onquit oninterrupt handlers
#QUIT
#EXIT -- on exit calls
#ERR -- set -e
#TERM
#HUP
#INT
#PIPE

# SIGINT
function int_handler {
    error "^C\nAborted (Ctrl-c) by user on line $1 in $BASENAME."
	print_stack
	if type -t oninterrupt &>/dev/null; then
		oninterrupt
	fi
    kill -SIGINT $$ # Propagate signal
	if is_interactive; then
		return
	fi
    exit 130 # Default SIGINT status code is 130
}
trap 'int_handler $LINENO' INT

# SIGEXIT
function exit_handler {
	internal_clean_up
	if type -t onexit &>/dev/null; then
		onexit
	fi
}
trap 'exit_handler' EXIT

# SIGHUP
function hup_handler {
	if ! has_terminal; then
		# TODO: this signal should be sent by a user.
		# this script should be some kind of daemon, and user want it
		# to re read configuration files
		if type -t onhup &>/dev/null; then
			onhup
		fi
		return
	fi
	error "Got HUP signal!"
	internal_clean_up
	if type -t onhup &>/dev/null; then
		onhup
	fi
	exit 1
}
trap 'hup_handler' HUP

# Handle uncaught errors
# SIGERR
function err_handler {
	internal_clean_up
	print_stack_summary
	print_stack
	if type -t onerr &>/dev/null; then
		onerr
	fi
    exit 1
}
trap 'err_handler $LINENO' ERR

# SIG TERM
function term_handler {
	internal_clean_up
    error "Got term signal on line $1"
	print_stack
	if type -t onterm &>/dev/null; then
		onterm
	fi
    exit 1
}
trap 'term_handler' TERM

# == OUTPUT FUNCTIONS AND LOGGERS ==
function color_echo {
	for word in "$@"; do
		case "$word" in
			NORMAL|RESET) echo -n -e "\033[0;00m";;
			BLACK) echo -n -e "\033[22;30m";;
			RED|--ERROR|--ERR) echo -n -e "\033[22;31m";;
			GREEN|--INFO) echo -n -e "\033[22;32m";;
			YELLOW|--WARNING|--WARN) echo -n -e "\033[22;33m";;
			BLUE) echo -n -e "\033[22;34m";;
			MAGENTA) echo -n -e "\033[22;35m";;
			CYAN) echo -n -e "\033[22;36m";;
			GRAY|WHITE) echo -n -e "\033[22;37m";;
			LGRAY|DARKGRAY|BRIGHTBLACK|--DEBUG) echo -n -e "\033[01;30m";;
			LRED|LIGHTRED|BRIGHTRED|--FATAL) echo -n -e "\033[01;31m";;
			LGREEN|LIGHTGREEN|BRIGHTGREEN) echo -n -e "\033[01;32m";;
			LYELLOW|LIGHTYELLOW|BRIGHTYELLOW) echo -n -e "\033[01;33m";;
			LBLUE|LIGHTBLUE|BRIGHTBLUE) echo -n -e "\033[01;34m";;
			LMAGENTA|LIGHTMAGENTA|BRIGHTMAGENTA) echo -n -e "\033[01;35m";;
			LCYAN|LIGHTCYAN|BRIGHTCYAN) echo -n -e "\033[01;36m";;
			LWHITE|LIGHTWHITE|BRIGHTWHITE) echo -n -e "\033[01;37m";;
			*) echo -n "$word ";;
		esac
	done
	echo -e "\033[0;00m"
}

function echo_ {
	if is_running_via_cron; then
		return
	fi
	if ! is_stdout_a_terminal; then
		echo "$@"
		return
	fi
	color_echo "$@"
}

function log {
	if [ -z "$LOG_FILE" ]; then
		return
	fi
	local level=$1
	shift
	if [ "$LOG_FILE" == "syslog" ]; then
		logger -p "$LOG_SYSLOG_FACILITY":$(lc "$level")  -t "$BASENAME" "$@"
	fi
	printf "$(date '+%F %T,%N') $BASENAME: $(uc "$level") $@\n" >> ${LOG_FILE}
}

function debug {
	local regex='^(DEBUG)$'
	[[ "$OUTPUT_LEVEL" =~ $regex ]] && echo_ --DEBUG "$@"
	[[ "$LOG_LEVEL" =~ $regex ]] && log DEBUG "$@"
	return 0
}

function info {
	local regex='^(DEBUG|INFO)$'
	[[ "$OUTPUT_LEVEL" =~ $regex ]] && echo_ --INFO "$@"
	[[ "$LOG_LEVEL" =~ $regex ]] && log INFO "$@"
	return 0
}

function warn {
	local regex='^(DEBUG|INFO|WARN)$'
	[[ "$OUTPUT_LEVEL" =~ $regex ]] && echo_ --WARN "$@"
	[[ "$LOG_LEVEL" =~ $regex ]] && log WARN "$@"
	return 0
}

function error {
	local regex='^(DEBUG|INFO|WARN|ERROR)$'
	[[ "$OUTPUT_LEVEL" =~ $regex ]] && echo_ --ERROR "$@"
	[[ "$LOG_LEVEL" =~ $regex ]] && log ERROR "$@"
	return 0
}

# == DEBUG FUNCTIONS ==

function start_time_debug {
	TMP_PS4="$PS4"
	PS4='+\t '
	set -xv
}

function stop_time_debug {
	set +xv
	PS4="$TMP_PS4"
}

# from http://blog.yjl.im/2012/01/printing-out-call-stack-in-bash.html

function print_line {
	local FILE=$1
	local LINE=$2
	local i=0
	while read fileline; do
		let i=i+1
		if [ "$i" -eq "$LINE" ]; then
			echo $fileline
			break
		fi
	done <$FILE
}

function print_stack {
	if is_interactive; then
		return
	fi
	local i=0
	local FRAMES=${#BASH_LINENO[@]}
    # FRAMES-2 skips main, the last one in arrays
	for ((i=FRAMES-2; i>=1; i--)); do
		debug "  File \"${BASH_SOURCE[i+1]}\", line ${BASH_LINENO[i]}, in ${FUNCNAME[i+1]}"
        # Grab the source code of the line
		local LINE=$(print_line "${BASH_SOURCE[i+1]}" "${BASH_LINENO[i]}")
		debug "    $LINE"
	done
}

# TODO: see bashinator stack implementation
function print_stack_summary {
	if is_interactive; then
		return
	fi
	local i=0
	local FRAMES=${#BASH_LINENO[@]}
	local OUTPUT=
    # FRAMES-2 skips main, the last one in arrays
	for ((i=FRAMES-2; i>=0; i--)); do
		OUTPUT="$OUTPUT> ${FUNCNAME[i+1]} "
	done
	debug "$OUTPUT"
}


#trap 'print_stack_summary' RETURN
